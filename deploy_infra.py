#!/usr/bin/env python
import yaml
from jinja2 import Template
import argparse
from os import path
import subprocess
import tempfile

template_dir='templates'
environments_dir = 'environments'

parser = argparse.ArgumentParser(description='Deploy CloudFormation stacks')
parser.add_argument('--environment-name',
                    dest='environment_name',
                    help='Name of the environment you want to deploy')
parser.add_argument('--environment-id',
                    dest='environment_id',
                    help='Unique ID of the environment')
parser.add_argument('--app-name',
                    dest='app_name',
                    help='Application name')
args = parser.parse_args()

if None in [args.environment_name, args.environment_id, args.app_name]:
    raise parser.error(message="Please provide an environment and id to deploy.")

environment_name = args.environment_name
environment_id = args.environment_id
app_name = args.app_name
environment_file = f"{args.environment_name}-{args.environment_id}.yaml"

with open(path.join(environments_dir, environment_file), 'r') as f:
    lines = f.read()
    try:
        t = Template(lines)
        environment_data=yaml.safe_load(
            t.render(
                environment_name=environment_name,
                environment_id=environment_id,
                app_name=app_name
                ))
    except yaml.YAMLError as e:
        print(e)

for stack_data in environment_data:

    stack_name = f"{environment_name}-{environment_id}-{app_name}-{stack_data['TemplateName']}"
    parameter_overrides = []
    template_file = path.join(template_dir, f"{stack_data['TemplateName']}.yaml")
    
    print(f"Deploying stack: {stack_name}")

    command = [
        "aws",
        "cloudformation",
        "deploy",
        "--stack-name",
        stack_name,
        "--template",
        template_file,
        "--capabilities",
        "CAPABILITY_IAM",
        #"--disable-rollback",
        "--parameter-overrides"   
    ]

    for k, v in stack_data['Parameters'].items():
        command.append(f"{k}={v}")
    
    with subprocess.Popen(command, stdout=subprocess.PIPE) as proc:
        print(proc.stdout.read().decode())