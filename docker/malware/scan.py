from time import sleep
import boto3
import json
import os
import logging
from botocore.exceptions import ClientError
import requests

debug_enabled = os.environ.get('DEBUG', 1)
if debug_enabled == 1:
    log_level = logging.DEBUG
else:
    log_level = logging.INFO

logger = logging.getLogger('Container logger')
logger.setLevel(log_level)
ch = logging.StreamHandler()
ch.setLevel(log_level)
formatter = logging.Formatter('%(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)

def receive_messages(queue_url, max_number_of_messages = 1, wait_timeout_seconds = 10):
    logger.info("Retreiving messages from queue")
    sqs = boto3.client("sqs", os.environ['AWS_REGION'])
    response = sqs.receive_message(
        QueueUrl=queue_url,
        MaxNumberOfMessages=max_number_of_messages,
        WaitTimeSeconds=wait_timeout_seconds,
    )

    if response.get("Messages", None):
        logger.debug(f"Number of messages received: {len(response.get('Messages', []))}")
	
    return response.get("Messages", None)

def delete_message(queue_url, receipt_handle):
    logger.info(f"Deleting file from queue")
    sqs = boto3.client("sqs", os.environ['AWS_REGION'])
    response = sqs.delete_message(
        QueueUrl=queue_url,
        ReceiptHandle=receipt_handle,
    )

def scan_file(filename):
    logger.info(f"Scanning {filename}")
    enable_task_termination_protection(True)
    sleep(5)
    #TODO: run actual scan
    # return true if clean, false if file needs to be quarantined
    enable_task_termination_protection(False)
    retval=True

    namespace = f"{ENVIRONMENT_NAME}-{ENVIRONMENT_ID}-malware"
    if retval:
        logger.info(f"File {filename} is clean")
        put_metric_data(namespace, 'files_clean', 1, 'Count')
    else:
        logger.info(f"File {filename} contains malware!")
        put_metric_data(namespace, 'files_infected', 1, 'Count')
    return retval

def delete_file_local(filename):
    logger.info(f"Deleting file {filename} from local disk")
    os.remove(os.path.join(TEMP_FOLDER, filename))

def delete_file_remote(bucket, key):
    logger.info(f"Purging local copy of {key}")
    #TODO: add S3 deletion code when done testing

def copy_from_s3(bucket, key):
    logger.info(f"Downloading {key} from {bucket}")
    S3.download_file(
        bucket,
        key,
        os.path.join(TEMP_FOLDER, key)
    )

def upload_to_destination(key, clean):
    if clean:
        bucket = CLEAN_BUCKET
    else:
        bucket = QUARANTINE_BUCKET

    logger.info(f"Copying {key} to {bucket}")   
    S3.upload_file(os.path.join(TEMP_FOLDER, key), bucket, key)

    #TODO implement checksum
    #s3_checksum = S3.get_key(file_name).etag[1:-1]
    #local_checksum = find_checksum(file_name)

    #if s3_checksum != local_checksum:

def publish_to_sns(sub, msg):
    logger.debug(f"Topic ARN: {os.environ['SNS_TOPIC_ARN']}")
    try:
        sns = boto3.client("sns", region_name=os.environ['AWS_REGION'])
        response = sns.publish(
            TopicArn=os.environ['SNS_TOPIC_ARN'],
            Message=msg,
            Subject=sub
        )
    except ClientError:
        logger.exception(f"Couldn't send sns notification regarding: {sub}")
        raise

def put_metric_data(namespace, name, value, unit):
    """
    Sends a single data value to CloudWatch for a metric. This metric is given
    a timestamp of the current UTC time.
    :param namespace: The namespace of the metric.
    :param name: The name of the metric.
    :param value: The value of the metric.
    :param unit: The unit of the metric.
    """ 
    try:
        cw = boto3.resource('cloudwatch')
        metric = cw.Metric(namespace, name)
        metric.put_data(
            Namespace=namespace,
            MetricData=[{
                'MetricName': name,
                'Value': value,
                'Unit': unit
            }]
        )
        logger.info("Put data for metric %s.%s", namespace, name)
    except ClientError:
        logger.exception("Couldn't put data for metric %s.%s", namespace, name)
        raise

def enable_task_termination_protection(protection_status: bool):
    url = f"{os.environ['ECS_AGENT_URI']}/task-protection/v1/state"

    r = requests.put(url, params={'ProtectionEnabled': protection_status})

    logger.info(r.content)

if __name__ == '__main__':
    for var in ["VIRUS_SCAN_QUEUE_URL", 'QUARANTINE_BUCKET', 'CLEAN_BUCKET', 'SNS_TOPIC_ARN', 'ENVIRONMENT_NAME', 'ENVIRONMENT_ID']:
        if var not in os.environ:
            raise EnvironmentError("Please set environment variable {}.".format(var))
    SQS = boto3.client("sqs")
    S3 = boto3.client("s3")
    VIRUS_SCAN_QUEUE_URL = os.environ['VIRUS_SCAN_QUEUE_URL']
    QUARANTINE_BUCKET = os.environ['QUARANTINE_BUCKET']
    CLEAN_BUCKET = os.environ['CLEAN_BUCKET']
    SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
    ENVIRONMENT_NAME = os.environ['ENVIRONMENT_NAME']
    ENVIRONMENT_ID = os.environ['ENVIRONMENT_ID']
    TEMP_FOLDER="/tmp"





    logger.info("Listening for new files")
    while True:
        messages = receive_messages()
        if messages != None:
            print(type(messages))
            for message in messages:
                try:
                    logger.debug(message)

                    message_body = json.loads(message["Body"])
                    key = message_body['detail']['object']['key']
                    bucket = message_body['detail']['bucket']['name']
                    receipt_handle = message["ReceiptHandle"]

                    copy_from_s3(bucket, key)
                    clean = scan_file(key)
                    upload_to_destination(key, clean)
                    delete_file_local(key)
                    delete_file_remote(bucket, key)
                    delete_message(receipt_handle)
                    logger.info(f"Processing {key} from bucket {bucket} done.")

                except Exception as e:
                    publish_to_sns(
                        "Malware scanning failed",
                        f"Error while scanning {key} from S3 bucket {bucket}, please investigate."
                    )
                    raise e
            
        else:
            sleep(5)